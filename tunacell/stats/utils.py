#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
This module sets up:
    * iterating over timeseries
    * defining regions for stationary analysis
    * defining computation options for stationary analysis
"""
import os
import logging
import string
import csv
import numpy as np
from tqdm import tqdm

from tunacell.base.parser import Parser
from tunacell.base.experiment import Experiment
from tunacell.io import analysis
from tunacell.base.observable import set_observable_list


logger = logging.getLogger(__name__)


def iter_timeseries_(exp, observable, conditions, size=None):
    """Iterator over :class:`TimeSeries` instances from lineages in exp.

    TimeSeries are generated by browing Lineages instances from exp,
    retrieving observable values as defined un Observable, under different
    conditions defined in Conditions

    Parameters
    ----------
    exp : :class:`Experiment` instance
    observable : :class:`Observable` or :class:`FunctionalObservable` instance
    conditions : list of :class:`FilterSet` instances

    size : int (default None)
        when not None, limit the iterator to size items.

    Yields
    ------
    :class:`TimeSeries` instance
    """
    all_filters = [exp.fset, ] + conditions
    raw_obs, func_obs = set_observable_list(observable, filters=all_filters)
    # run the iterator
    if exp._counts is None:
        exp.count_items()
    n_lineages = exp._counts['lineages']
    for lineage in tqdm(exp.iter_lineages(size=size), total=n_lineages, desc='sample iteration'):
        ts = lineage.get_timeseries(observable,
                                    raw_obs=raw_obs, func_obs=func_obs,
                                    cset=conditions)
        yield ts


def iter_timeseries_2(exp, obs1, obs2, conditions, size=None):
    """Iterator over couples :class:`TimeSeries` instances

    :class:`TimeSeries` are generated by browing :class:`Lineage` instances
    from exp, retrieving observable values as defined in obs1 and obs2,
    under different conditions.

    Parameters
    ----------
    exp : :class:`Experiment` instance
    obs1 : :class:`Observable` instance
    obs2 : :class:`Observable` instance
    conditions : list of :class:`FilterSet` instances
    size : int (default None)
        when not None, limit the iterator to size items.

    Yields
    ------
    Couple of :class:`TimeSeries` instances
    """
    all_filters = [exp.fset, ] + conditions
    raw_obs, func_obs = set_observable_list(obs1, obs2, filters=all_filters)
    if exp._counts is None:
        exp.count_items()
    n_lineages = exp._counts['lineages']
    for lineage in tqdm(exp.iter_lineages(size=size), total=n_lineages, desc='sample iteration'):
        ts1 = lineage.get_timeseries(obs1,
                                     raw_obs=raw_obs, func_obs=func_obs,
                                     cset=conditions)
        ts2 = lineage.get_timeseries(obs2,
                                     raw_obs=raw_obs, func_obs=func_obs,
                                     cset=conditions)
        yield (ts1, ts2)


class CompuParamsError(ValueError):
    pass


class CompuParams(object):
    """Options for the computation of statistics under stationary hypothesis
    """

    def __init__(self, adjust_mean='global', disjoint=True):
        if adjust_mean not in ['global', 'local']:
            raise CompuParamsError('adjust mean must one of global, local')
        self.adjust_mean = adjust_mean
        if not isinstance(disjoint, bool):
            raise CompuParamsError('disjoint must be boolean: True, False')
        self.disjoint = disjoint

    def as_string_code(self):
        code = ''
        code += self.adjust_mean[0]
        if self.disjoint:
            code += 'd'
        return code

    def load_from_string_code(self, code):
        if not isinstance(code, str):
            raise CompuParamsError('argument must be a string')
        if code[0] == 'g':
            self.adjust_mean = 'global'
        elif code[0] == 'l':
            self.adjust_mean = 'local'
        else:
            raise CompuParamsError('adjust_mean not valid in {}'.format(code))
        self.disjoint = False
        if len(code) > 1:
            if code[1] == 'd':
                self.disjoint = True
            else:
                raise CompuParamsError('string {} not valid'.format(code))


class RegionsIOError(IOError):
    pass


class UndefinedRegion(ValueError):
    pass


class Region(object):
    """Minimal object that store region parameters

    Parameters
    ----------
    name : str
        name of region
    tmin : str, int, or float
        lower bound for acquisition time values
    tmax : float
        upper bound for acquisition time values
    """

    def __init__(self, name=None, tmin=None, tmax=None):
        self.name = name
        if isinstance(tmin, str):
            self.tmin = eval(tmin)  # will evaluate as int or float
        else:
            self.tmin = tmin
        if isinstance(tmax, str):
            self.tmax = eval(tmax)
        else:
            self.tmax = tmax

    def as_dict(self):
        return {'name': self.name, 'tmin': self.tmin, 'tmax': self.tmax}

    def __repr__(self):
        msg = 'Region : {{name: {}, tmin: {}, tmax: {}}}'.format(self.name, self.tmin, self.tmax)
        return msg


class Regions(object):
    """Class that stores regions for stationary analysis.

    A region is defined by lower- and upper-bound for times.

    Parameters
    ----------
    exp : :class:`Experiment` instance or :class:`Parser` instance
    """

    def __init__(self, exp):
        if isinstance(exp, Experiment):
            self.exp = exp
        elif isinstance(exp, Parser):
            self.exp = exp.experiment
        else:
            raise TypeError('first arg must be either Experiment or Parser')
        self._regions = {}  # dictionary name: region
        try:
            self.load()
            _all = self.get('ALL')
            self._tmin = _all.tmin  # experiment lower bound
            self._tmax = _all.tmax  # experiment upper bound
        except RegionsIOError:
            logger.debug('No regions have been saved yet. '
                         'Looking for experiment boundaries...')
            tmin, tmax = _find_time_boundaries(self.exp)
            self.add(name='ALL', tmin=tmin, tmax=tmax)
            self._tmin = tmin
            self._tmax = tmax

    @property
    def names(self):
        return list(self._regions)  # return list of keys

    def __repr__(self):
        text_file = self._path_to_file(write=False)
        with open(text_file, 'r') as f:
            msg = f.read()
        return msg

    def _path_to_file(self, write=False):
        analysis_path = analysis.get_analysis_path(self.exp, write=write)
        text_file = os.path.join(analysis_path, 'regions.tsv')
        if not os.path.exists(text_file) and not write:
            raise RegionsIOError
        return text_file

    def load(self):
        text_file = self._path_to_file(write=False)
        with open(text_file, 'r') as f:
            items = csv.DictReader(f, delimiter='\t')
            for item in items:  # item is a dict with keys name, tmin, tmax
                name = item['name']
                self._regions[name] = item

    def save(self):
        if self._regions is not None:
            text_file = self._path_to_file(write=True)
            with open(text_file, 'w') as f:
                fieldnames = ['name', 'tmin', 'tmax']
                writer = csv.DictWriter(f, fieldnames, delimiter='\t')
                writer.writeheader()
                # sort rows
                names = sorted(self._regions.keys())
                for name in names:
                    item = self._regions[name]
                    writer.writerow(item)

    def _lookup_bounds(self, tmin=None, tmax=None):
        """Look up in defined regions whether a region already exists

        Parameters
        ----------
        tmin : float or int (default None)
        tmax : float or int (default None)

        Returns
        -------
        str
            region name when found, else None
        tmin : float (or int)
            lower bound for time values
        tmax : float (or int)
            upper bound for time values
        """
        # convert to defined values
        if tmin is None or tmax is None:
            left, right = self._tmin, self._tmax
            if tmin is None:
                tmin = left
            if tmax is None:
                tmax = right
        name = None
        for key, item in self._regions.items():
            if item['tmin'] == tmin and item['tmax'] == tmax:
                name = item['name']
                break
        return name, tmin, tmax

    def add(self, region=None, name=None, tmin=None, tmax=None):
        """Add a new region to existing frame.

        Parameters
        ----------
        region : :class:`Region` instance
            when left to None, following keyword arguments are used
        name : str
            name of region to be added
        tmin : float
            lower bound for acquisition time values
        tmax : float
            upper bound for acquisition time values

        Returns
        -------
        name : str
            name of the region that has been added (or found)

        Raises
        ------
        TypeError
            when region is provided and not a Region
        """
        if region is not None:
            if isinstance(region, Region):
                # check that name is not used yet
                _name, _tmin, _tmax = self._lookup_bounds(tmin=region.tmin, tmax=region.tmax)
            else:
                logger.error('"region" argument is not an instance of Region')
                raise TypeError('Argument not a Region')
        # otherwise use other keyword arguments
        else:
            _name, _tmin, _tmax = self._lookup_bounds(tmin=tmin, tmax=tmax)
        # region already exists
        if _name is not None:
            if _name == name:
                logger.debug('Region "{}" already exists and match parameters'.format(name))
            else:
                logger.warning('Region parameters match region "{}" which is used'.format(_name))
            return self._regions[_name][_name]
        # region does not exists yet
        else:
            # find a name starting with 'A', 'B', ..., 'Z', then 'A1', 'B1', ...
            if name is None:
                _name = _find_available_name(used_names=self.names)
            else:
                _name = name
            item = {'name': _name, 'tmin': _tmin, 'tmax': _tmax}
            # okay we can add the region to the list of regions
            msg = ('Adding region {} with parameters: '.format(item['name']) + ''
                   'tmin: {}'.format(item['tmin']) + ', '
                   'tmax: {}'.format(item['tmax']))
            logger.debug(msg)
            self._regions[item['name']] = item
            # automatic saving
            self.save()
            return item['name']

    def delete(self, name):
        """Delete name region

        Parameters
        ----------
        name : str
            name of the region to delete
        """
        if name in self.names:
            del self._regions[name]
        self.save()

    def reset(self):
        """Delete all regions except 'ALL'"""
        names = self.names[:]
        for name in names:
            if name != 'ALL':
                self.delete(name)

    def get(self, name):
        """Get region parameters corresponding to name

        Parameters
        ----------
        name : str
            name of region

        Returns
        -------
        :class:`Region` instance

        Raises
        ------
        :class:`UndefinedRegion` when name is not in the list
        """
        if name not in self.names:
            raise UndefinedRegion(name)
        item = self._regions[name]
        return Region(**item)


def _find_time_boundaries(exp):
    """Returns min and max value for time values

    Parameters
    ----------
    exp : :class:`tunacell.base.experiment.Experiment` instance

    Returns
    -------
    tleft : float (or int)
        minimum time value in experiment
    tright : float (or int)
        maximum time value in experiment
    """
    tleft, tright = np.infty, -np.infty
    logger.debug('Parsing experiment to get min, max values for registered times')
    for container in exp.iter_containers(read=True, build=False):
        tmin = np.nanmin(container.data['time'])
        tmax = np.nanmax(container.data['time'])
        if tmin < tleft:
            tleft = tmin
        if tmax > tright:
            tright = tmax
    logger.debug('Boundaries found: min {} max {}'.format(tleft, tright))
    return tleft, tright


def _find_available_name(used_names=[]):
    """Find a new name by parsing alphabetical order

    Parameters
    ----------
    used_names : list of str

    Returns
    -------
    str
        new name
    """
    got_it = False
    num = 0
    while not got_it:
        upper = string.ascii_uppercase
        index = 0
        while index < 26:
            if num == 0:
                letter = upper[index]
            else:
                letter = upper[index] + '{}'.format(num)
            if letter not in used_names:
                got_it = True
                break
            index += 1
        num += 1
    return letter


def _dtype_converter(col_name):
    """Use to convert dtype of column name in pandas import

    As boolean arrays are exported for FilterSet objects (conditions), they
    should be imported as such dtype.

    Parameters
    ----------
    col_name : str

    Returns
    -------
    dtype : np.dtype
        returns None when dtype is not recognized (pandas parser will deal with it)
    """
    dtype = None
    if 'FilterSet' in col_name:
        dtype = np.bool
    elif col_name == 'cellID':
        dtype = np.int64
    return dtype